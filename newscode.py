import asyncio
import httpx
import time
import sqlite3
from telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.error import TelegramError
from datetime import datetime
import pytz
import os
import json
import aiohttp # <-- ‡¶õ‡¶¨‡¶ø ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶°‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶®‡¶§‡ßÅ‡¶® ‡¶≤‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∞‡¶ø
import aiodns # <-- aiohttp-‡¶è‡¶∞ DNS ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø

# --- [‡¶Æ‡¶°‡¶ø‡¶â‡¶≤ ‡ßß: ‡¶ö‡ßÇ‡ßú‡¶æ‡¶®‡ßç‡¶§ ‡¶è‡¶¨‡¶Ç ‡¶®‡¶ø‡¶∞‡ßç‡¶≠‡¶∞‡¶Ø‡ßã‡¶ó‡ßç‡¶Ø ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶®] ---
BOT_TOKEN_HARDCODED = "8328958637:AAEZ88XR-Ksov_RHDyT0_nKPgBEL1K876Y8"
CHANNEL_ID_HARDCODED = "-1002557789082"
BITLY_TOKEN_HARDCODED = "2feb4ec89bdbb72e24eaf85536d6149d948393cc"

BOT_TOKEN = os.environ.get("BOT_TOKEN", BOT_TOKEN_HARDCODED)
CHANNEL_ID = os.environ.get("CHANNEL_ID", CHANNEL_ID_HARDCODED)
BITLY_ACCESS_TOKEN = os.environ.get("BITLY_ACCESS_TOKEN", BITLY_TOKEN_HARDCODED)

DATABASE_FILE = "hybrid_news_database.db"

# --- [‡¶Æ‡¶°‡¶ø‡¶â‡¶≤ ‡ß®: ‡¶°‡ßá‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶ú‡¶Æ‡ßá‡¶®‡ßç‡¶ü] (‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§) ---
def setup_database():
    conn = sqlite3.connect(DATABASE_FILE)
    cursor = conn.cursor()
    cursor.execute('CREATE TABLE IF NOT EXISTS posted_articles (unique_id TEXT PRIMARY KEY, source TEXT NOT NULL)')
    conn.commit()
    conn.close()

def is_article_posted(unique_id):
    conn = sqlite3.connect(DATABASE_FILE)
    cursor = conn.cursor()
    cursor.execute('SELECT unique_id FROM posted_articles WHERE unique_id = ?', (unique_id,))
    result = cursor.fetchone()
    conn.close()
    return result is not None

def add_article_to_db(unique_id, source):
    conn = sqlite3.connect(DATABASE_FILE)
    cursor = conn.cursor()
    cursor.execute('INSERT INTO posted_articles (unique_id, source) VALUES (?, ?)', (unique_id, source))
    conn.commit()
    conn.close()

# --- [‡¶Æ‡¶°‡¶ø‡¶â‡¶≤ ‡ß©: ‡¶®‡ßá‡¶ü‡¶ì‡ßü‡¶æ‡¶∞‡ßç‡¶ï ‡¶è‡¶¨‡¶Ç ‡¶á‡¶â‡¶ü‡¶ø‡¶≤‡¶ø‡¶ü‡¶ø] ---
async def create_retry_client():
    """API ‡¶°‡ßá‡¶ü‡¶æ ‡¶Ü‡¶®‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ httpx ‡¶ï‡ßç‡¶≤‡¶æ‡ßü‡ßá‡¶®‡ßç‡¶ü‡•§"""
    transport = httpx.AsyncHTTPTransport(retries=3)
    client = httpx.AsyncClient(transport=transport, timeout=30)
    print("‚úÖ [SUCCESS] ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶æ‡¶∞‡ßç‡¶° httpx ‡¶ï‡ßç‡¶≤‡¶æ‡ßü‡ßá‡¶®‡ßç‡¶ü ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")
    return client

async def fetch_api_data(session, url):
    try:
        response = await session.get(url, headers={'User-Agent': 'Mozilla/5.0'})
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"[{time.strftime('%H:%M:%S')}] [NETWORK ERROR] API ‡¶•‡ßá‡¶ï‡ßá ‡¶°‡ßá‡¶ü‡¶æ ‡¶Ü‡¶®‡¶æ‡¶∞ ‡¶∏‡¶Æ‡ßü ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {url} | ‡¶è‡¶∞‡¶∞: {e}")
        return None

# --- [‡¶®‡¶§‡ßÅ‡¶® ‡¶Æ‡¶°‡¶ø‡¶â‡¶≤: aiohttp ‡¶¶‡¶ø‡ßü‡ßá ‡¶õ‡¶¨‡¶ø ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶°] ---
async def download_image_with_aiohttp(photo_url):
    """
    aiohttp ‡¶è‡¶¨‡¶Ç ‡¶ï‡¶æ‡¶∏‡ßç‡¶ü‡¶Æ DNS ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶õ‡¶¨‡¶ø ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡ßá‡•§
    ‡¶è‡¶ü‡¶ø httpx-‡¶è‡¶∞ DNS ‡¶è‡¶¨‡¶Ç SSL ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶è‡ßú‡¶ø‡ßü‡ßá ‡¶Ø‡¶æ‡ßü‡•§
    """
    try:
        # ‡¶ó‡ßÅ‡¶ó‡¶≤ DNS ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ï‡¶æ‡¶∏‡ßç‡¶ü‡¶Æ resolver ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá
        resolver = aiohttp.resolver.AsyncResolver(nameservers=["8.8.8.8", "1.1.1.1"])
        connector = aiohttp.TCPConnector(resolver=resolver, ssl=False) # SSL ‡¶≠‡ßá‡¶∞‡¶ø‡¶´‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶¨‡¶æ‡¶á‡¶™‡¶æ‡¶∏ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá
        
        async with aiohttp.ClientSession(connector=connector) as session:
            headers = {'Referer': 'https://www.prothomalo.com/', 'User-Agent': 'Mozilla/5.0'}
            async with session.get(photo_url, headers=headers) as response:
                response.raise_for_status()
                return await response.read() # ‡¶õ‡¶¨‡¶ø‡¶∞ ‡¶¨‡¶æ‡¶á‡¶ü‡¶∏ ‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá
    except Exception as e:
        print(f"‚ùå‚ùå [AIOHTTP ERROR] aiohttp ‡¶¶‡¶ø‡ßü‡ßá ‡¶õ‡¶¨‡¶ø ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶∏‡¶Æ‡ßç‡¶≠‡¶¨ ‡¶π‡ßü‡¶®‡¶ø: {e}")
        return None

# --- [send_news_alert ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®‡¶ü‡¶ø ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá] ---
async def send_news_alert(bot: Bot, news_info: dict, session: httpx.AsyncClient):
    headline = news_info.get('title', 'N/A')
    subheadline = news_info.get('subheadline') or ''
    message = f"<b>{headline}</b>\n\n{subheadline}"
    # shorten_url ‡¶è‡¶ñ‡¶® httpx session ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßá
    short_url = await shorten_url(session, news_info.get('url', '#'))
    keyboard = [[InlineKeyboardButton("üìÑ ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶™‡ßú‡ßÅ‡¶®", url=short_url)]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    photo_url = news_info.get('photo_url')
    
    try:
        if photo_url:
            print(f"--> [INFO] ‡¶õ‡¶¨‡¶ø‡¶∏‡¶π ‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá (Method: aiohttp)‡•§ ‡¶õ‡¶¨‡¶ø‡¶∞ URL: {photo_url}")
            # ‡¶®‡¶§‡ßÅ‡¶® ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ‡¶¶‡¶ø‡ßü‡ßá ‡¶õ‡¶¨‡¶ø ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá
            photo_bytes = await download_image_with_aiohttp(photo_url)
            
            if photo_bytes:
                await bot.send_photo(chat_id=CHANNEL_ID, photo=photo_bytes, caption=message, parse_mode='HTML', reply_markup=reply_markup)
            else:
                # ‡¶õ‡¶¨‡¶ø ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶π‡¶≤‡ßá, ‡¶õ‡¶¨‡¶ø ‡¶õ‡¶æ‡ßú‡¶æ‡¶á ‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶¨‡ßá
                print("--> [FALLBACK] ‡¶õ‡¶¨‡¶ø ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶π‡¶ì‡ßü‡¶æ‡ßü, ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§")
                await bot.send_message(chat_id=CHANNEL_ID, text=message, parse_mode='HTML', reply_markup=reply_markup, disable_web_page_preview=True)
        else:
            await bot.send_message(chat_id=CHANNEL_ID, text=message, parse_mode='HTML', reply_markup=reply_markup, disable_web_page_preview=True)
            
        print(f"--> [SUCCESS] ‡¶ñ‡¶¨‡¶∞ '{headline}' ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤‡ßá ‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")
        return True
    except Exception as e:
        print(f"‚ùå‚ùå [SEND ERROR] ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶∏‡¶Æ‡ßç‡¶≠‡¶¨ ‡¶π‡ßü‡¶®‡¶ø: {e}")
        return False

# --- [‡¶¨‡¶æ‡¶ï‡¶ø ‡¶ï‡ßã‡¶° ‡¶™‡ßç‡¶∞‡¶æ‡ßü ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§] ---
async def shorten_url(session, long_url):
    if not BITLY_ACCESS_TOKEN or BITLY_ACCESS_TOKEN == "YOUR_BITLY_ACCESS_TOKEN_HERE":
        return long_url
    bitly_api_url = "https://api-ssl.bitly.com/v4/shorten"
    headers = {"Authorization": f"Bearer {BITLY_ACCESS_TOKEN}", "Content-Type": "application/json"}
    payload = {"long_url": long_url}
    try:
        response = await session.post(bitly_api_url, headers=headers, json=payload)
        return response.json().get("link", long_url)
    except Exception:
        return long_url

async def send_job_alert(bot: Bot, job_info: dict, session: httpx.AsyncClient):
    message = (f"<b>üì¢ ‡¶®‡¶§‡ßÅ‡¶® ‡¶∏‡¶∞‡¶ï‡¶æ‡¶∞‡¶ø ‡¶ö‡¶æ‡¶ï‡¶∞‡¶ø‡¶∞ ‡¶¨‡¶ø‡¶ú‡ßç‡¶û‡¶™‡ßç‡¶§‡¶ø!</b>\n\n<b>üè¢ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶∑‡ßç‡¶†‡¶æ‡¶®:</b> {job_info.get('organization', 'N/A')}\n<b>üìÑ ‡¶∂‡¶ø‡¶∞‡ßã‡¶®‡¶æ‡¶Æ:</b> {job_info.get('title', 'N/A')}\n<b>üìÖ ‡¶Ü‡¶¨‡ßá‡¶¶‡¶®‡ßá‡¶∞ ‡¶∂‡ßá‡¶∑ ‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ:</b> {job_info.get('end_date', 'N/A')}\n")
    details_url = await shorten_url(session, job_info.get('url', '#'))
    apply_url = await shorten_url(session, job_info.get('apply_url', '#'))
    keyboard = [[InlineKeyboardButton("üìÑ ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®", url=details_url)], [InlineKeyboardButton("‚úÖ ‡¶Ü‡¶¨‡ßá‡¶¶‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®", url=apply_url)]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await bot.send_message(chat_id=CHANNEL_ID, text=message, parse_mode='HTML', reply_markup=reply_markup, disable_web_page_preview=True)
    return True

def find_image_url_from_story(story_data):
    try:
        if key := story_data.get("metadata", {}).get("social-share", {}).get("image", {}).get("key"):
            return f"https://images.prothomalo.com/{key}"
        if "cards" in story_data:
            for card in story_data.get("cards", []):
                for element in card.get("story-elements", []):
                    if element.get("type") == "image" and element.get("image-s3-key"):
                        return f"https://images.prothomalo.com/{element['image-s3-key']}"
    except Exception as e:
        print(f"--> [WARN] ‡¶õ‡¶¨‡¶ø ‡¶™‡¶æ‡¶∞‡ßç‡¶∏ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡ßü ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ö‡¶™‡ßç‡¶∞‡¶§‡ßç‡¶Ø‡¶æ‡¶∂‡¶ø‡¶§ ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶ò‡¶ü‡ßá‡¶õ‡ßá: {e}")
    return None

async def check_teletalk_jobs(session, bot):
    print(f"[{time.strftime('%H:%M:%S')}] [CHECK] Teletalk ‡¶•‡ßá‡¶ï‡ßá ‡¶ö‡¶æ‡¶ï‡¶∞‡¶ø‡¶∞ ‡¶ñ‡¶¨‡¶∞ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...")
    url = "https://alljobs.teletalk.com.bd/api/v1/govt-jobs/list?skipLimit=YES"
    response = await fetch_api_data(session, url)
    if response and response.get("status") == "success":
        for job in reversed(response.get("data", [])):
            job_id = f"teletalk_{job.get('id')}"
            if job_id and not is_article_posted(job_id):
                print(f"--> [NEW JOB] ‡¶®‡¶§‡ßÅ‡¶® ‡¶ö‡¶æ‡¶ï‡¶∞‡¶ø ‡¶∏‡¶®‡¶æ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá: ‡¶Ü‡¶á‡¶°‡¶ø {job_id}")
                try: end_date = datetime.strptime(job.get("application_end_date"), "%Y-%m-%d").strftime("%d %B, %Y")
                except: end_date = "N/A"
                base_url = "https://alljobs.teletalk.com.bd"
                circular_path = job.get("circular_link")
                job_info = {"title": job.get("job_title"), "organization": job.get("organization"), "end_date": end_date, "url": f"{base_url}{circular_path}" if circular_path else base_url, "apply_url": f"{base_url}/jobs/government/{job.get('organization_slug', '')}/apply/{job.get('id')}"}
                if await send_job_alert(bot, job_info, session):
                    add_article_to_db(job_id, "teletalk")
                    await asyncio.sleep(5)

async def check_prothomalo_news(session, bot):
    print(f"[{time.strftime('%H:%M:%S')}] [CHECK] Prothom Alo ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶∞‡ßç‡¶¨‡¶∂‡ßá‡¶∑ ‡¶ñ‡¶¨‡¶∞ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...")
    url = "https://www.prothomalo.com/api/v1/collections/latest?limit=15&item-type=story&fields=id,headline,slug,url,subheadline,cards,metadata"
    response = await fetch_api_data(session, url)
    if response and response.get("items"):
        for story_wrapper in reversed(response["items"]):
            story_data = story_wrapper.get("story", {})
            story_id = f"palo_{story_wrapper.get('id')}"
            headline = story_data.get("headline")
            slug = story_data.get("slug")
            
            if story_id and headline and not is_article_posted(story_id):
                print(f"--> [NEW POST] ‡¶®‡¶§‡ßÅ‡¶® ‡¶ñ‡¶¨‡¶∞ ‡¶∏‡¶®‡¶æ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá: {headline}")
                subheadline = story_data.get("subheadline")
                photo_url = find_image_url_from_story(story_data)
                
                news_info = {"title": headline, "subheadline": subheadline, "url": f"https://www.prothomalo.com/{slug}", "photo_url": photo_url}
                if await send_news_alert(bot, news_info, session):
                    add_article_to_db(story_id, "prothomalo")
                    await asyncio.sleep(10)

async def main_loop():
    if not BOT_TOKEN or not CHANNEL_ID or "YOUR_BOT_TOKEN_HERE" in BOT_TOKEN:
        print("‚ùå [FATAL] BOT_TOKEN or CHANNEL_ID is not set.")
        return

    bot = Bot(token=BOT_TOKEN)
    # httpx ‡¶ï‡ßç‡¶≤‡¶æ‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶ü‡¶ø ‡¶∂‡ßÅ‡¶ß‡ßÅ API ‡¶°‡ßá‡¶ü‡¶æ ‡¶Ü‡¶®‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡¶¨‡ßá
    httpx_session = await create_retry_client()
    
    if httpx_session is None:
        print("‚ùå [FATAL] HTTP Client could not be created. Exiting.")
        return

    try:
        await bot.get_me()
        await bot.send_message(chat_id=CHANNEL_ID, text="‚úÖ ‡¶∏‡¶Æ‡¶®‡ßç‡¶¨‡¶ø‡¶§ ‡¶®‡¶ø‡¶â‡¶ú ‡¶ì ‡¶ú‡¶¨ ‡¶¨‡ßÅ‡¶≤‡ßá‡¶ü‡¶ø‡¶® ‡¶¨‡¶ü ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ö‡¶®‡¶≤‡¶æ‡¶á‡¶®‡•§ (Build: aiohttp-Final)")
        print("‚úÖ [SUCCESS] ‡¶¨‡¶ü ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶ü‡ßá‡¶≤‡¶ø‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶® ‡¶ï‡¶∞‡ßá‡¶õ‡ßá‡•§")
    except Exception as e:
        print(f"‚ùå [STARTUP FAILED] Could not connect to Telegram. Error: {e}")
        return

    print("--- [INFO] Hybrid scheduler is now running. ---")

    while True:
        try:
            # check ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®‡¶ó‡ßÅ‡¶≤‡ßã‡¶§‡ßá httpx ‡¶∏‡ßá‡¶∂‡¶®‡¶ü‡¶ø ‡¶™‡¶æ‡¶∏ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá
            await check_teletalk_jobs(httpx_session, bot)
            await check_prothomalo_news(httpx_session, bot)
            check_interval_minutes = 5
            print(f"[{time.strftime('%H:%M:%S')}] [SLEEP] Waiting for {check_interval_minutes} minutes...")
            await asyncio.sleep(check_interval_minutes * 60)
        except Exception as e:
            print(f"‚ùå [MAIN LOOP ERROR] An unexpected error occurred: {e}")
            await asyncio.sleep(60)

if __name__ == '__main__':
    print("--- [INFO] Initializing database... ---")
    setup_database()
    
    print("--- [INFO] Starting bot... ---")
    try:
        asyncio.run(main_loop())
    except KeyboardInterrupt:
        print("\n--- [INFO] Bot is shutting down. ---")
    except Exception as e:
        print(f"‚ùå [CRITICAL] A fatal error occurred while starting the program: {e}")
